# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Opens a .pgen or PLINK 1 .bed file.
#'
#' @param filename .pgen/.bed file path.
#' @param pvar Object (see NewPvar()) corresponding to the .pgen's companion
#' .pvar; technically optional, but necessary for some functionality.
#' @param raw_sample_ct Number of samples in file; required if it's a PLINK 1
#' .bed file, otherwise optional.
#' @param sample_subset List of 1-based positions of samples to load;
#' optional, all samples are loaded if this is not specified.
#' @export
NewPgen <- function(filename, pvar = NULL, raw_sample_ct = NULL, sample_subset = NULL) {
    .Call(`_pgenlibr_NewPgen`, filename, pvar, raw_sample_ct, sample_subset)
}

#' Returns the number of samples in the file.
#'
#' @param pgen Object returned by NewPgen().
#' @export
GetRawSampleCt <- function(pgen) {
    .Call(`_pgenlibr_GetRawSampleCt`, pgen)
}

#' Returns the number of variants in the file.
#'
#' @param pgen Object returned by NewPgen().
#' @export
GetVariantCt <- function(pvar_or_pgen) {
    .Call(`_pgenlibr_GetVariantCt`, pvar_or_pgen)
}

#' Returns max(2, <number of alleles the variant_numth variant is known to
#' have>).  Could be smaller than the actual number of alleles if no pvar was
#' provided to the NewPgen() call.
#'
#' @param pgen Object returned by NewPgen().
#' @param variant_num Variant index (1-based).
#' @export
GetAlleleCt <- function(pvar_or_pgen, variant_num) {
    .Call(`_pgenlibr_GetAlleleCt`, pvar_or_pgen, variant_num)
}

#' Returns max(2, <maximum number of alleles any variant is known to have>).
#' Could be smaller than the true number if no pvar was provided to the
#' NewPgen() call.
#'
#' @param pgen Object returned by NewPgen().
#' @export
GetMaxAlleleCt <- function(pvar_or_pgen) {
    .Call(`_pgenlibr_GetMaxAlleleCt`, pvar_or_pgen)
}

#' Returns true iff the file contains at least one phased heterozygous
#' hardcall.
#'
#' @param pgen Object returned by NewPgen().
#' @export
HardcallPhasePresent <- function(pgen) {
    .Call(`_pgenlibr_HardcallPhasePresent`, pgen)
}

#' Returns a numeric buffer that Read() or ReadHardcalls() can load to.
#'
#' @param pgen Object returned by NewPgen().
#' @export
Buf <- function(pgen) {
    .Call(`_pgenlibr_Buf`, pgen)
}

#' Returns an empty two-row numeric matrix that ReadAlleles() can load to.
#'
#' @param pgen Object returned by NewPgen().
#' @export
AlleleCodeBuf <- function(pgen) {
    .Call(`_pgenlibr_AlleleCodeBuf`, pgen)
}

#' Returns an integer buffer that ReadHardcalls() can load to.
#'
#' @param pgen Object returned by NewPgen().
#' @export
IntBuf <- function(pgen) {
    .Call(`_pgenlibr_IntBuf`, pgen)
}

#' Returns an empty two-row integer matrix that ReadAlleles() can load to.
#'
#' @param pgen Object returned by NewPgen().
#' @export
IntAlleleCodeBuf <- function(pgen) {
    .Call(`_pgenlibr_IntAlleleCodeBuf`, pgen)
}

#' Returns a bool buffer that ReadAlleles() can load phasing information to.
#'
#' @param pgen Object returned by NewPgen().
#' @export
BoolBuf <- function(pgen) {
    .Call(`_pgenlibr_BoolBuf`, pgen)
}

#' Loads the variant_numth variant, and then fills buf with {0, 1, 2, NA}
#' values indicating the number of copies of the first ALT (or user-specified)
#' allele each sample has.
#'
#' @param pgen Object returned by NewPgen().
#' @param buf Buffer returned by Buf() or IntBuf().
#' @param variant_num Variant index (1-based).
#' @param allele_num Allele index; 1 corresponds to REF, 2 to the first ALT
#' allele, 3 to the second ALT allele if it exists, etc.  Optional, defaults
#' 2.
#' @export
ReadHardcalls <- function(pgen, buf, variant_num, allele_num = 2L) {
    invisible(.Call(`_pgenlibr_ReadHardcalls`, pgen, buf, variant_num, allele_num))
}

Read <- function(pgen, buf, variant_num, allele_num = 2L) {
    invisible(.Call(`_pgenlibr_Read`, pgen, buf, variant_num, allele_num))
}

ReadAlleles <- function(pgen, acbuf, variant_num, phasepresent_buf = NULL) {
    invisible(.Call(`_pgenlibr_ReadAlleles`, pgen, acbuf, variant_num, phasepresent_buf))
}

ReadIntList <- function(pgen, variant_subset) {
    .Call(`_pgenlibr_ReadIntList`, pgen, variant_subset)
}

ReadList <- function(pgen, variant_subset, meanimpute = FALSE) {
    .Call(`_pgenlibr_ReadList`, pgen, variant_subset, meanimpute)
}

VariantScores <- function(pgen, weights, variant_subset = NULL) {
    .Call(`_pgenlibr_VariantScores`, pgen, weights, variant_subset)
}

ClosePgen <- function(pgen) {
    invisible(.Call(`_pgenlibr_ClosePgen`, pgen))
}

#' Loads variant IDs and allele codes from a .pvar or .bim file (which can be
#' compressed with gzip or Zstd).
#'
#' @param filename .pvar/.bim file path.
#' @export
NewPvar <- function(filename) {
    .Call(`_pgenlibr_NewPvar`, filename)
}

#' Returns the variant_numth variant ID.
#'
#' @param pvar Object returned by NewPvar().
#' @param variant_num Variant index (1-based).
#' @export
GetVariantId <- function(pvar, variant_num) {
    .Call(`_pgenlibr_GetVariantId`, pvar, variant_num)
}

#' Returns a list of all (1-based) variant indices with the given variant ID.
#'
#' @param pvar Object returned by NewPvar().
#' @param id Variant ID to look up.
#' @export
GetVariantsById <- function(pvar, id) {
    .Call(`_pgenlibr_GetVariantsById`, pvar, id)
}

#' Returns the allele_numth allele code for the variant_numth variant.
#' allele_num=1 corresponds to the REF allele, allele_num=2 corresponds to the
#' first ALT allele, allele_num=3 corresponds to the second ALT allele if it
#' exists and errors out otherwise, etc.
#'
#' @param pvar Object returned by NewPvar().
#' @param variant_num Variant index (1-based).
#' @param allele_num Allele index (1-based).
#' @export
GetAlleleCode <- function(pvar, variant_num, allele_num) {
    .Call(`_pgenlibr_GetAlleleCode`, pvar, variant_num, allele_num)
}

#' Closes a pvar object, releasing memory.
#'
#' @param pvar Object returned by NewPvar().
#' @export
ClosePvar <- function(pvar) {
    invisible(.Call(`_pgenlibr_ClosePvar`, pvar))
}

